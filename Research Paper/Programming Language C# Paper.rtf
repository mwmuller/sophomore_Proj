{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033\deflangfe1041{\fonttbl{\f0\fswiss\fprq2\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.15063}{\*\mmathPr\mnaryLim0\mdispDef1\mwrapIndent1440 }\viewkind4\uc1 
\pard\nowidctlpar\sa200\sl276\slmult1\qc\f0\fs22\lang9 C# Programming Language Research Paper\par

\pard\nowidctlpar\sa200\sl276\slmult1\tab I am going to be doing my research paper on the C# Programming Language. In this paper I will be discussing the advantages and disadvantages of the languages efficiency, simplicity, orthogonality, definiteness, reliability, program verification, abstraction facilities, and its portability. I want to start off by going over a little of the languages history to talk about how C# came about, and why. More specifically, what task(s) would creating this language simplify or improve?\par
\tab The C# Programming Language is a General Purpose OOPS Programming language that was developed in 2000 by Microsoft, whose development team was led by Andres Hejlsberg. [1]The language was developed under Microsoft's .NET framework initiative. C# Programming Language is one of the languages designed for the Common Language Infrastructure, which enables an application program written in one of several different programming languages to run using a common runtime program rather than a language specific one.[1]\par

\pard\nowidctlpar\sa200\sl276\slmult1\qc\ul\b Efficiency\ulnone\b0\par

\pard\nowidctlpar\sa200\sl276\slmult1\tab When you run a C# program, it is first compiled into the module, which is then converted into assembly. The assembly contains the Intermediate Language (IL) code, along with the metadata information about the assembly. From there, the common language runtime (CLR) works with the assembly to convert it into machine code for execution by the operating system. [18][5]\par
\tab This process of translating while executing can help improve the performance of a C# program, but it still takes away from the efficiency as a whole. We can take a look at arguably the fastest programming language out there, C.[19] One of the biggest speed drawbacks to C# is the translation of the code into machine code for execution. You have compilers such as Visual Basic, and it does take several seconds to compile any piece of code. On a good note however, this time is usually the same due to the Just-in-time that is used which allows for the program to be translated during the execution of the program. In terms of strict execution however, the difference in speed between C# and C is only noticeable when the load is heavy. in general, under common use cases, all programming languages will execute roughly at the same speed. As the load gets increasingly large though, we see those numbers start to spread. The illusion here is that C's execution speed is inherently faster than C#, which isn't really true.[5] Since execution is handled with machine code, it is mostly based on the CPU to handle that code. What we are really looking at is the translation of the language itself.[19]\par
\tab The biggest hit to C# in the efficiency category is time. C has had a very long to become more optimized and since it is widely used, it will continue to be optimized. While C# is not even 2 decades old[1]. Besides that though, the easier a programming language is to code in, the longer the execution times. If the programmer can do more with less in a different language, then we have to make it up during the translation and execution process. C was created to be efficient, C# was developed out of an initiative for a framework. It's not to say that in time C# will not become faster or more efficient, but due to the way it was developed, it will never be on that 'C' level.[19] Though again, it is because there are far more efficient C compilers than there are C# compilers.\par

\pard\nowidctlpar\sa200\sl276\slmult1\qc\ul\b Simplicity\ulnone\b0  \par

\pard\nowidctlpar\sa200\sl276\slmult1\tab C# as a whole is similar to C++ and java, but with several of the complexities, like macros, multiple inheritance and templates removed.[2] Because C# is similar to C++ and Java, you can go from learning to C++ and Java into programming in C# with relative ease. The statements, expressions, operators and functions are take directly from C/C++, with several improvements to make it simpler. For example, in the C# language, to write to the console you simply input the 'Console.WriteLine()' statement. For most programmers, whether at the professional or beginner level, understanding that you will be outputting text to the console should be an easy concept. On a more advanced level, in C++, operators for working members have three operands for working with members: '::', '.', and '->'. It can be difficult to know when exactly to use each of these. In contrast, in the C# language, you only need to use the '.' operator[2][3].  \par
\tab The reduction of operands for working members and the elimination of several redundancies has improved the readability of C#. In addition to the improvements C# allows developers to create User-defined structs and enumerations to help clear up what may be confusing[2]. One of my personal favorite changes from C++ to C# is how we reference namespaces. It is a small change but the key word "using" is much easier to understand than "import" or "include". It is simple changes like this that help as new programmer immerse themselves in C# without getting lost. \par
\tab While C# may have good readability for new programmers, its writability has a high knowledge cap. I use C# in my job dealing with socket communication between programs. As I started working, I had finished connection and stream communication between the programs over an Ethernet cable. After a few weeks, I went back after doing some research and I was able to rewrite a lot of the code to improve its functionality. It is very powerful to have the ability to write a program that works and then improve it by adding in more advanced coding techniques with only a small margin of improvement. It's the small margin of improvement that allows for beginner to harness the power of this language and implement their ideas and still have very reasonable results.\par

\pard\nowidctlpar\sa200\sl276\slmult1\qc\ul\b Orthogonality\ulnone\b0\par

\pard\nowidctlpar\sa200\sl276\slmult1\tab In C# as well as in Java, it is very common to come across "public static" methods and variables. It's difficult to prove a language is orthogonal and which parts of a language are orthogonal, as you would need to test each combination to find out. I am going to be listing off a few of the data types/methods that I use that are orthogonal.[7] \par
\tab As I mentioned above, mixing "public" and "static" in both Java and C# is common, especially in the initial "Main" for a program. A "static" method doesn't need to be invoked by creating an instance of a class. It also allows for the change of static data members. The way I see it, the "static" declaration limits all interaction to that of only "static" type, in most cases. In addition to "public static" you can also interchange "public" with "private", "protected", or no prior indicator.[8]\par
\tab My personal experience with C# isn't too extensive and, while it's shared among all languages, I believed its orthogonality can be advocated because of its leniency on the implementation of access to user-based types and structures. While I may not know the inherent orthogonal methods/types of C#, I am aware of how easy it is to implement my own methods and interfaces to complete a multitude of tasks. The use of my own structs and enumerations make it much easier to create handlers and formatters for transferring packets and information over a network. I think its C#'s "sandbox" creation that hits the attribute of orthogonality home. If I am not aware of a certain way to do a task, I can start from a new foundation and create it. This isn't limited to C# either. But in terms of inherent orthogonality, I don't really use it too often, so my experience with it is low.\par

\pard\nowidctlpar\sa200\sl276\slmult1\qc\ul\b Definiteness\ulnone\b0\par

\pard\nowidctlpar\sa200\sl276\slmult1\tab Most programming languages use a very similar form of syntax in terms of symbols. in C#, like a majority of the top languages requires semi-colons at the end of statements, uses curly braces to define code blocks, variables are assigned using equal signs and square blocks are used for arrays. This is very close to the core syntax of both C++ and Java.[4]  The only language I have worked with that differed greatly from C# was Python. And this difference had everything to do with how we align code blocks.[10] Instead of using curly braces and semi-colons, we use indentation and colons. Personally I think the way C#'s syntax works suites me best, as I can read the code easier with braces and semi-colons. As far as statement syntax is concerned, it will very much more from language to language.[11][10] From Java to C# there are very minor differences which are usually just name changes for integrated methods such as the C#'s 'Console.WriteLine()' and Java's System.out.println()'.[4]  And even from C++ to C# the only major change is how input and output is done. C++ uses 'cout << ' to denote a print statement as opposed to the previously stated C# version.[11]\par
\tab Along the syntax topic we can also look at the semantics of C#. Like most programming languages, the relational, equality, logical and assignment operators also work nearly identically.[4] I think the advantages and disadvantages of syntax or semantics for C# will be either closely related or identical to those of C++ and Java. It really just depends on what you prefer and what task you need to get done. I have worked extensively with both Java and C#, both are great languages, but one thing that irritates me about Java is it's checked exceptions. I cannot tell you how many times I have written an 'IO' statement that required me to throw an exception in several other places.[4] It can get overwhelming at times. C#, on the other hand, does not require this. Depends on how you look at it though. It could be a good thing if you know what you are doing, and for me, it is. I think of it more of a luxury than anything else. \par

\pard\nowidctlpar\sa200\sl276\slmult1\qc\ul\b Reliability\ulnone\b0\par

\pard\nowidctlpar\sa200\sl276\slmult1\tab Since C# allows for static typing, we know it is inherently more reliable that some other languages like Perl, Ruby and Python as there is less room for interpretation error. [13][12]Since C# is statically typed, we know the type of the variables when the code is compiled, instead of finding out at runtime. [12]This allows us to catch errors upon compilation that otherwise would not be found until it was encountered during the execution. This can be seen in python as we do not need to give a type for our variables, we need to know what type they are and make the appropriate conversions if needed. [13]\par
\tab Though, since C# is a simplified version of C/C++ and Java meshed together, it will have some holes where the utilities of the lower level language C++ that cannot be accessed reliably. [3][19]If you are dealing with low-level mappings or device drivers, you will need C++ in order to get the same level of output. If you try and use a high level language or a low level purpose, the overhead from the C# will show in its lack of execution whereas C++ would excel. [3]\par

\pard\nowidctlpar\sa200\sl276\slmult1\qc\ul\b Program Verification\ulnone\b0\par

\pard\nowidctlpar\sa200\sl276\slmult1\tab It\rquote s difficult to compare correctness, as a whole, between two languages. So, I wanted to look at the \ldblquote const\rdblquote  type qualifier in the C/C++ languages as that point of comparison. [16]\ldblquote Const\rdblquote  is applied to a data type to indicate that data is read-only. While, when used in good practice, this can help optimize the code for the compiler, it doesn\rquote t mean this data cannot change! In C/C++ you can also add the \ldblquote volatile\rdblquote  qualifier which will indicates to the compiler the data could change, but it was not intended to change. [15][17]C#, however, does not support the \ldblquote const\rdblquote  as it is not supported by CLI. Why is this a problem? What are the advantages? \par
\tab Since C# doesn\rquote t have the \ldblquote const\rdblquote  qualifier, a programmer will need to improvise, usually by writing a method that will consists of pseudo \ldblquote const\rdblquote  types. Basically meaning they are private and the method only allows for get methods. [16]This is actually vert useful though! While it falls on the programmer to create a solid \ldblquote const\rdblquote  class that will perform as a \ldblquote const\rdblquote  data type would. While it\rquote s not perfect, and you wouldn\rquote t be able to capitalize on the optimization of \ldblquote const\rdblquote , it will perform roughly the same. [16]Since \ldblquote const\rdblquote  will cause the variables to be determined at runtime, it does keep memory relatively low and can also catch type-check exceptions if you attempt to change the read-only data. [17] Having the ability to create how you want data to be changed is powerful when you want to make special exceptions. Personally, while it may be more optimized to use \ldblquote const\rdblquote , I prefer to create my own classes and methods to handle data. I like to have move control with my work. \par

\pard\nowidctlpar\sa200\sl276\slmult1\qc\ul\b Abstraction Facilities\ulnone\b0\par

\pard\nowidctlpar\sa200\sl276\slmult1\tab C# supports abstract data types with both classes and structs. Structs are considered the values types and they do not support inheritance. Another form or abstraction is abstract base classes. These cannot be instantiated and all the implementations of the methods in the abstract class is made in the derived classes. [Concepts of Programming Languages, p.390-393]\par
\tab When we use an abstract base class in C#, we will add the class to the derived class at the top of the class name. We can also add the "partial" if the class we are using is stored in another physical file. [14]The use of these "partial" abstract base classes are frequent in the project I am working on with sockets. We can denote an abstract base class like this: "public partial class Thisclass : Abs_base_class".[14] I have several reference to Abstract base classes and it is very similar to a path. You have a line of abstract base classes all being called until we reach the parent base class. Since I have several different objects that refer to this base class, the use of "partial" is required.\par
\tab Process abstractions, or sub-programs, are obviously useful in programming. Since I deal a lot with threading, I need to make sure my sub programs can efficiently carry out a task, so as not to bog down the rest of the program. The use of process abstraction is to combat the complexity of a large program with several smaller programs that will ultimately carry out a task. [Concepts of Programming Languages, p.390-393]Since C# was developed with the Common Language Infrastructure in mind, it was developed for multiple platforms from the beginning. Some C# programs can be created for the command line, so the majority of platform are going to be able to run a C# program. Even if the platform does not support the command line, a C# program can be re-written for several over platforms. [14]While the language may have been developed for multiple platforms though, you may still need to compile the program before it can execute. Since C#, as talked about at the beginning, has a slower compilation time, it is possible for this fact to be the limiting facing when it comes to the portability to another platform. [14][3][5]If we can assume a platform has the platform we wish to move to has the hardware capable to efficiently compiling the program, then C# will have no problem. This is strictly referring to the execution of the program.\par

\pard\nowidctlpar\sa200\sl276\slmult1\qc\ul\b Portability\ulnone\b0\par

\pard\nowidctlpar\sa200\sl276\slmult1\tab As far as the portability of the code, that may change based on the compiler being used. In the Java language it is possible to write your code in one compiler and then not be able to easily convert it over to another compiler.[9] A great example of this is IntelliJ and Netbeans.[3] If a program is written in IntelliJ, you cannot simply add the project to Netbeans. You will need to manually transfer the .Java files over to a new project in Netbeans. This issue can also be seen, in a similar fashion, when moving from Visual Basic to Monodevelope. In order to do so you will need to incorporate the MSBuild to help convert. [9]\par
\tab As a whole, the C# language is extremely powerful. In each category it does not fall short by too much from the other languages that excel in those categories. And while I love working with C#, I would someday like to move on to a lower level language such as C++ again because, as of now, it seems more interesting. I think that is very important to consider when determining which language to code in for a specific task. Which language do you like more or would prefer to know more about. Granted this is true to an extent, where some languages are just made for certain tasks. \par
}
 