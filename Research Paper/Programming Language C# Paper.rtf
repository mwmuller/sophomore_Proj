{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.15063}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\f0\fs22\lang9 Programming Language Research Paper\par

\pard\sa200\sl276\slmult1\tab I am going to be doing my research paper on the C# Programming Language. In this paper I will be discussing the advantages and disadvantages of the langauges efficiency, simplicity, orthogonality, definiteness, reliability, program verification, abstraction facilities, and its portability. I want to start off by going over a little of the languages history to talk about how C# came about, and why. More specifically, what task(s) would creating this language simplify or improve?\par
\tab The C# Programming Language is a General Purpose OOPS Programming language that was developed in 2000 by Microsoft, whose development team was lead by Andres Hejisberg. The language was developed under Microsoft's .NET framerwork initiative. C# Programming Language is one of the languages designed for the Common Language Infrstructure, which enables an application program written in one of several different programming languages to run using a common runtime program rather than a language specific one.\par
\tab When you run a C# program, it is first compiled into the module, which is then converted into assembly. The assembly contains the Intermediate Langauge (IL) code, along with the metadata inforamtion about the assembly. From there, the common language runtime (CLR) works with the assembly to convert it into machine code for execution by the operating system. \par
\tab This process of translating while executiung can help improve the performance of a C# program, but it still takes away from the efficeincy as a whole. We can take a look at arguably the fastest programming language out there, C. One of the biggest speed drawbacks to C# is the translation of the code into machine code for execution. You have compilers such as Visual Basic, and it does take several seconds to compile any piece of code. On a good note however, this time is usually the same due to the Just-in-time that is used which allows for the progam to be translated during the execution of the program. In terms of strict execution however, the difference in speed between C# and C is only noticible when the load is heavy. in general, under common use cases, all programming langauges will execute roughly at the same speed. As the load gets increasingly large though, we see those numbers start to spread. The illusion here is that C's execution speed is inherently faster than C#, which isn't really true. Since execution is handled with machine code, it is mostly based on the CPU to handle that code. What we are really looking at is the translation of the langauge itself.\par
\tab The biggest hit to C# in the effficeincy category is time. C has had a very long to become more optomized and since it is widley used, it will continue to be optimized. While C# is not even 2 decades old. Besides that though, the easier a programming language is to code in, the longer the execution times. If the programmer can do more with less in a different language, then we have to make it up during the translation and execution process. C was created to be efficient, C# was developed out of an initiative for a framework. It's not to say that in time C# will not become faster or more efficient, but due to the way it was developed, it will never be on that 'C' level. Though again, it is because there are far more efficent C compilers than there are C# compilers. \par
\tab C# as a whole is similar to C++ and java, but with several of the complexities, like macros, multiple inheritence and tmeplates removed. Beacuse C# is similar to C++ and Java, you can go from learning to C++ and Java into programming in C# with relative ease. The statements, expressions, operators and functions are take directly from C/C++, with several improvements to make make it simpler. For example, in the C# language, to write to the console you simply input the 'Console.WriteLine()' statement. For mose programmers, whether at the professional or begginner level, understandign that you will be outputting text to the console should be an easy concept. On a more advanced level, in C++, operators for working members have three operands for working with members: '::', '.', and '->'. It can be diffcult to know when exactly to use each of these. In contrast, in the C# language, you only need to use the '.' operator.  \par
\tab The reduction of operands for working members and the elimination of several redundancies has improved the readablity of C#. In addition to the improvements C# allows developers to create User-defined structs and enumerations to help clear up what may be confusing. One of my personal favorite changes from C++ to C# is how we reference namespaces. It is a small change but the key word "using" is much easier to undersatnd than "import" or "include". It is simple changes like thius that help as new programmer immerse themself in C# without getting lost. \par
\tab While C# may have good readability for new programmers, it's writability has a high knowledge cap. I use C# in my job dealing with socket communication between programs. As I started working, I had finished connection and stream communication bewteen the programs over an ethernet cable. After a few weeks, I went back after doing some research and I was able to rewrite a lot of the code to improve it's functionality. It is very powerful to have the ability to write a program that works and then improve it by adding in more advanced coding techniques with only a small margin of improvement. It's the small margin of improvement that allows for begginner to harness the power of this language and implement their ideas and still have very reasonable results.\par
\tab C# is not without it's drawbacks in the simplicity department though. For readability it is easy to get confused with the amount of ailiasing that can takeplace. On the other side of the coin we have the issues with writability. As I mentioned above, with a high knowledge cap to fully utilize the C# language, it is difficult to understand when to use the more advanced techniques. In many cases, for me persoanly this is in regards to adding classes to handle my own enumerations, using these techniques will only improve the readability for the next programmer. For my project currently, since timing is not a huge issue, I would rather improve the read and writability for future changes than to improve performance by a few miliseconds. \par
\tab In C# as well as in Java, it is very common to come across "public static" methods and variables. It's difficult to prove a language is orthogonal and which parts of a language are orthogonal, as you would need to test each combination to find out. I am going to be listing off a few of the data types/methods that I use that are orthogonal. \par
\tab As I mentioed above, mixing "public" and "static" in both Java and C# is common, especially in the initial "Main" for a program. A "static" method doesn't need to be invoked by creating an instance of a class. It also allows for the change of static data members. The way I see it, the "static" decleration limits all interaction to that of only "static" type, at least in my experience. In addition to "public static" you can also interchange "public" with "private", "protected", or no prior indicator.\par
\tab My personal experience with C# isn't too extensive and, while it's shared among all languages, I believed it's orthognality can be advocated because of it's leniency on the implementation of access to user-based types and structures. While I may not know the inherent orthogonal methods/types of C#, I am aware of how easy it is to implement my own methods and interfaces to complete a multitude of tasks. The use of my own structs and enumeratios make it much easier to create handlers and formatters for transfering packets and information over a network. I think it's C#'s "sandbox" creation that hits the attribute of orthogonality home. If I am not aware of a certain way to do a task, I can start from a new foundation and create it. This isn't limited to C# either. But in terms of inherint orthogonality, I don't really use it too often, so my expereince with it is low.\par
\tab Most programming languages use a very similar form of syntax in terms of symbols. in C#, like a majority of the top languages requires semi-colons at the end of statements, uses curly braces to define code blocks, variables are assigned using equal signs and square blocks are used for arrays. This is very close to the core syntax of both C++ and Java.  The only langauge I have worked with that differed greatly from C# was Python. And this difference had everything to do with how we align code blocks. Instead of using curly braces and semi-colons, we use indentation and colons. Perosnally I think the way C#'s syntax works suites me best, as I can read the code easier with braces and semi-colons. As far as statement syntax is concered, it will very much more from language to language. From Java to C# there are very minor differences which are usually just name changes for intigrated methods such as the C#'s 'Console.WriteLine()' and Java's System.out.println()'.  And even from C++ to C# the only major change is how input and output is done. C++ uses 'cout << ' to denote a print statement as opposed to the previously stated C# version.\par
\tab Along the syntax topic we can also look at the semantics of C#. Like most programming languages, the relational, equality, logical and assignment operators also work nearly identically. I think the advantages and disadvantages of syntax or semantics for C# will be either closely related or identical to those of C++ and Java. It really just depends on what you prefer and what task you need to get done. I have worked extensively with both Java and C#, both are great langauges, but one thing that irritates me about Java is it's checked exceptions. I cannot tell you how many times I ahve written an 'IO' statement that required me to throw an exception in several other places. It can get overwhelming at times. C#, on the other hand, does not require this. Depends on how you look at it though. It could be a good thing if you know what you are doing, and for me, it is. I think of it more of a luxury than anything else. \par
\tab Since C# allows for static typing, we know it is inherently more reliable that some other languages like Perl, Ruby and Python as there is less room for interpretation error. Since C# is statically typed, we know the type of the variables when the code is compiled, instead of finding out at runtime. This allows us to catch errors upon compilation that otherwise would not be found until it was encoutered during the execution. This can be seen in python as we do not need to give a type for our variables, we need to know what type they are and make the appropriate conversions if needed. \par
\tab Though, since C# is a simplified version of C/C++ and Java meshed together, it will have some holes where the utilites of the lower level language C++ that cannot be accessed reliably. If you are dealiong with lowlevel mappings or device drivers, you will need C++ in order to get the same level of output. If you try and use a high level language or a low level purpose, the overhead from the C# will show in it's lack of execution where as C++ would excel. \par
\par
 6. program verification (correctness)\par
\tab\par
 7. abstraction facilities (data and procedural)\par
\tab C# supports abstract data typers with both classes and structs. Structs are considered the values types and they do not support inheritence. Another form or abstraction is abstract base classes. These cannot be instantiated and all the implementations of the methods in the abstract class is made in the derived classes. \par
\tab When we use an abstract base class in C#, we will add the class to the derived class at the top of the class name. We can also add the "partial" if the class we are using is stored in another physical file. The use of these "partial" abstract base classes are frequent in the project I am working on with sockets. We can denote an abstract base class like this: "public partial class Thisclass : Abs_base_class". I have several reference to Abstract base classes and it is very similar to a path. You have a line of abstract base classes all being called until we reach the parent base class. Since I have several different objects that refer to this base class, the use of "partial" is required.\par
\tab Process abstractions, or sub-programs, are obviously useful in programming. Since I deal a lot with threading, I need to make sure my sub programs can efficiently carry out a task, so as not to bog down the rest of the program. The use of process abstraction is to combat the complexity of a large program with several smaller programs that will ultimatley carry out a task. Since C# was developed with the Common Language Infrastructure in mind, it was developed for multiple platforms from the beginning. Some C# programs can be careted for the command line, so the majority of platform are going to be able to run a C# program. Even if the platform does not support the command line, a C# program can be re-written for several over platforms. While the language may have been developed for multiple platforms though, you may still need to compile the program before it can execute. Since C#, as talked about at the beginning, has a slower compilation time, it is possible for this fact to be the limiting facting when it comes to the portability to another platform. If we can assume a platform has the platform we wish to move to has the hardware capable to efficiently compiling the program, then C# will have no problem. This is strictly referring to the execution of the program.\par
\tab As far as the portability of the code, that may change based on the compiler being used. In the Java language it is possible to write your code in one compiler and then not be able to easily convert it over to another compiler. A great example of this is IntelliJ and Netbeans. If a program is written in IntelliJ, you cannot simply add the project to Netbeans. You will need to manually transfer the .Java  files over t oa new project in Netbeans. This issue can also be seen, in a similar fashion, when moving from Visual Basic to Monodevelope. In order to do so you will need to incoroperate the MSBuild to help convert. \par
\tab As a whole, the C# language is extremely powerful. In each category it does not fall short by too much from the other languages that excel in those categories. And while I love working with C#, I would someday like to move on to a lower level langauge such as C++ again because, as of now, it seems more interesting. I think that is very important to consider when determining which language to code in for a specific task. Wheich language do you like more or would prefer to know more about. Granted this is true to an extent, where some langauges are just made for certain tasks. \par
}
 